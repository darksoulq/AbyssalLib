package com.github.darksoulq.abyssallib.world.data.loot;

import com.github.darksoulq.abyssallib.common.serialization.Codec;
import com.github.darksoulq.abyssallib.common.serialization.DynamicOps;
import com.github.darksoulq.abyssallib.server.registry.Registries;
import org.bukkit.inventory.ItemStack;

import java.util.Map;

/**
 * An abstract base class for functions that modify an {@link ItemStack} generated by a loot table.
 * <p>
 * Functions are applied sequentially to a loot entry. Common uses include setting
 * item amounts, applying enchantments, or modifying display names.
 */
public abstract class LootFunction {

    /**
     * Applies this function's logic to the provided item stack.
     *
     * @param stack   The {@link ItemStack} to be modified.
     * @param context The {@link LootContext} providing environmental data for the application.
     * @return The resulting modified {@link ItemStack}.
     */
    public abstract ItemStack apply(ItemStack stack, LootContext context);

    /**
     * Retrieves the specific type definition associated with this function.
     *
     * @return The {@link LootFunctionType} used for registry identification and serialization.
     */
    public abstract LootFunctionType<?> getType();

    /**
     * Polymorphic codec for serializing and deserializing loot functions.
     * <p>
     * Decodes the function by looking up the "type" field in the {@link Registries#LOOT_FUNCTIONS}
     * and delegating the rest of the object to that specific type's codec.
     */
    public static final Codec<LootFunction> CODEC = new Codec<>() {
        /**
         * Decodes a loot function from a serialized map.
         *
         * @param ops   The {@link DynamicOps} logic.
         * @param input The serialized data.
         * @param <D>   The data type.
         * @return The decoded {@link LootFunction}.
         * @throws CodecException If the type is missing or unknown.
         */
        @Override
        public <D> LootFunction decode(DynamicOps<D> ops, D input) throws CodecException {
            Map<D, D> map = ops.getMap(input).orElseThrow(() -> new CodecException("Expected map"));
            String typeId = ops.getStringValue(map.get(ops.createString("type"))).orElseThrow(() -> new CodecException("Missing function type"));
            LootFunctionType<?> type = Registries.LOOT_FUNCTIONS.get(typeId);
            if (type == null) throw new CodecException("Unknown loot function: " + typeId);
            return type.codec().decode(ops, input);
        }

        /**
         * Encodes a loot function into a serialized map.
         *
         * @param ops   The {@link DynamicOps} logic.
         * @param value The {@link LootFunction} to encode.
         * @param <D>   The data type.
         * @return The encoded data.
         * @throws CodecException If the function type is unregistered.
         */
        @Override
        @SuppressWarnings("unchecked")
        public <D> D encode(DynamicOps<D> ops, LootFunction value) throws CodecException {
            LootFunctionType<LootFunction> type = (LootFunctionType<LootFunction>) value.getType();
            String id = Registries.LOOT_FUNCTIONS.getId(type);
            if (id == null) throw new CodecException("Unregistered loot function type");

            D encoded = type.codec().encode(ops, value);
            Map<D, D> map = ops.getMap(encoded).orElseThrow(() -> new CodecException("Codec must return map"));
            map.put(ops.createString("type"), ops.createString(id));
            return ops.createMap(map);
        }
    };
}